---
title: J2SE HotSpot 虚拟机 GC 调优指南
author: Scott
tags:
  - Java
  - JVM
categories: []
date: 2019-07-03 10:44:00
---
JVM 为垃圾收集器、堆大小和运行时编译器提供了依赖于平台的默认选项。这些选项符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调优动态调整堆的大小，以满足应用程序的指定行为。

本节介绍这些默认选项和基于行为的调优。

### 垃圾收集器、堆和运行时编译器默认选项
服务器级机器定义：

* 2核以上的物理处理器；
* 2GB 以上的物理内存；

服务器级机器上的默认选项：

* Throughput 垃圾收集器；
* 初始堆大小为 1/64 的物理内存（上限 1GB）；
* 最大堆大小为 1/4 的物理内存（上限 1GB）；
* 运行时编译器使用 Server 模式；

有关 64 位系统的初始堆和最大堆大小，请参考[并行收集器（Parallel Collector）](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#CHDCFBIF)中的[默认堆大小](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size)一节。

> 服务器级机器的定义适用于除 32 位 Windows 系统之外的所有平台。

下表展示了各平台默认的运行时编译器模式：

|Platform| 操作系统 |默认编译器模式<sup>F1</sup>| 服务器级默认编译器模式<sup>F1</sup>|
|---|---|---|---|
|i586|Linux|Client|Server|
|i586|Windows|Client|Client<sup>F2</sup>|
|SPARC (64-bit)|Solaris|Server|Server<sup>F3</sup>|
|AMD (64-bit)|Linux|Server|Server<sup>F3</sup>|
|AMD (64-bit)|Windows|Server|Server<sup>F3</sup>|

> <sup>F1</sup>：Client 表示采用 Client 运行时编译器，Server 表示采用 Server 运行时编译器；
> <sup>F2</sup>：基于历史统计，Windows 32 位平台上大部分都是客户端应用，因此即使是服务器级的机器，也会默认采用 Client 运行时编译器；
> <sup>F3</sup>：只支持 Server 运行时编译器；

### 基于行为的调优
对于并行收集器，Java SE 提供了两个基于实现应用程序的特定行为的垃圾收集调整参数：最大暂停时间和吞吐量指标；请参阅 [并行收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#CHDCFBIF) 部分。（这两个选项在其他收集器中不可用。）这些指标不一定都能符合。程序需要足够大的堆，至少保存所有的实时数据。此外，最小堆大小可能会阻碍这些期望目标。

##### 最大暂停时间
暂停时间是垃圾收集器停止程序并回收废弃空间的所需时间。最大暂停时间指标的目的是限制这些暂停中最长的时间。暂停的平均时间和该平均值的方差由垃圾收集器维护。平均值是从执行开始获取的，但是是加权的，因此最近的暂停值会更长。如果平均值加上暂停时间的方差大于最大暂停时间目标，则垃圾回收器判定未达到指标。

最大暂停时间指标使用命令行 **`-XX：MaxGCPauseMillis = <nnn>`** 进行指定。它将提示垃圾收集器：需要 `<nnn>` 毫秒或更少的暂停时间。垃圾收集器将调整 Java 堆大小及与垃圾收集相关的其他参数，使垃圾收集暂停时间短于 `<nnn>` 毫秒。默认情况下，不设定最大暂停时间指标。这些调整可能导致垃圾回收器更频繁的进行回收，导致降低程序总体吞吐量。垃圾收集器将会优先满足暂停时间指标。但在某些情况下，始终无法满足所需的暂停时间指标。

##### 吞吐量指标
吞吐量指标是根据收集垃圾所花费的时间和垃圾收集之外的时间（称为应用程序时间）来衡量的，可以通过 `-XX：GCTimeRatio = <nnn>` 命令进行指定。垃圾收集时间与应用时间的比值为 `1 /(1 + <nnn>)`。例如，`-XX：GCTimeRatio = 19` 表示将垃圾回收总时间设定为 `1/20` 或 `5％` 。

> 垃圾回收耗时 = 年轻代回收耗时 + 老年代回收耗时

如果没有满足吞吐量指标，则通过增加代的大小来增加程序在所在区域内的运行时间。

##### 占用的空间
如果已经满足吞吐量和最大暂停时间指标，则减小堆的大小，直到其中某个指标不能满足（一般都是吞吐量），再来调整未达到的指标。

##### 调优策略
1. 除非你知道你需要一个大于默认最大值的堆，否则不要设置堆的最大值。可以设置吞吐量指标。
2. 吞吐量的升降会影响堆的伸缩。应用程序行为的更改可能导致堆增大或缩小。例如，如果应用程序以更高的速率开始分配，则吞吐量将升高，堆也将增长。
3. 如果堆已增长到最大值而吞吐量还在上升，则最大堆大小将不足以支撑设定的目标吞吐量。将最大堆大小设置为接近平台上总物理内存的值，再次执行应用程序。如果仍然未满足吞吐量目标，那么应用时间的目标对于平台上的可用内存来说要求太高。
4. 如果可以满足吞吐量，但暂停时间过长，则应设置最大暂停时间。设置最大暂停时间可能意味着不会达到吞吐量目标，那么可以设置一个可接受的折衷值。
5. 通常，当垃圾收集器试图满足各项目标的平衡时，即使应用程序已达到稳定状态，堆的大小也会振荡。主要是为了实现目标吞吐量（可能需要更大的堆）的压力与目标最大暂停时间和目标最小占用量（这两者都可能需要小堆）的平衡。

> 原文地址：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics